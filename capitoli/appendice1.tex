\chapter{Appendice: Codice sorgente}
In questa appendice e' riportato il codice sorgente utilizzato nel progetto.
\section{Codice in Python del server}
\begin{lstlisting}[style=pythonstyle,caption={Codice del server.py}, label={lst:server}]
from flask import Flask, json, request, jsonify
from chatbot import process_input
from mail_chatbot import send_email
import vector_db_maker as vector
import directory_manager as dm
app = Flask(__name__)
@app.route('/upload', methods=['OPTIONS', 'POST'])
async def upload_file():
    if request.method == 'OPTIONS':
        # Gestisci la richiesta OPTIONS
        response = app.make_default_options_response()
        # Aggiungi i metodi consentiti nella risposta
        response.headers['Access-Control-Allow-Methods'] = 'POST'
        # Aggiungi gli header consentiti nella risposta
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    elif request.method == 'POST':
        directory_name = "./data/"
        if 'jsonFile' in request.files :
            json_data = request.files['jsonFile'].read()
            json_dict = json.loads(json_data)
            directory_name += json_dict['userID'] + '/' + json_dict['directory_name']
        if 'files' not in request.files:
            return jsonify({'error': 'No file part'}), 400
        uploaded_files = request.files.getlist("files")
        file_names = []
        for file in uploaded_files:
            file.save(file.filename)
            file_names.append(file.filename)
        await vector.get_text(uploaded_files, directory_name)
        response = jsonify({'message': 'Files uploaded successfully', 'files': file_names})
    # Aggiungi gli header CORS alla risposta per consentire le richieste da origini diverse
    response.headers['Access-Control-Allow-Origin'] = '*'  # Cambia '*' con l'origine desiderata
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response
@app.route('/create_directory', methods=['OPTIONS', 'POST'])
def handle_create_directory():
    if request.method == 'OPTIONS':
        # Gestisci la richiesta OPTIONS
        response = app.make_default_options_response()
        # Aggiungi i metodi consentiti nella risposta
        response.headers['Access-Control-Allow-Methods'] = 'POST'
        # Aggiungi gli header consentiti nella risposta
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    elif request.method == 'POST':
        # Gestisci la richiesta POST
        data = request.json  # Ottieni i dati JSON dalla richiesta
        # Fai qualcosa con i dati ricevuti, ad esempio, restituisci una risposta
        user_id = data['userId']
        dm.create_user_directory(user_id)
        response = jsonify({'message': "user directory created"})
    else:
        # Se il metodo non e' OPTIONS o POST, restituisci un errore
        response = jsonify({'error': 'Metodo non supportato'})
        response.status_code = 405  # Metodo non consentito
    # Aggiungi gli header CORS alla risposta per consentire le richieste da origini diverse
    response.headers['Access-Control-Allow-Origin'] = '*'  # Cambia '*' con l'origine desiderata
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response
@app.route('/directory', methods=['OPTIONS', 'POST'])
def handle_request_directory():
    if request.method == 'OPTIONS':
        # Gestisci la richiesta OPTIONS
        response = app.make_default_options_response()
        # Aggiungi i metodi consentiti nella risposta
        response.headers['Access-Control-Allow-Methods'] = 'POST'
        # Aggiungi gli header consentiti nella risposta
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    elif request.method == 'POST':
        # Gestisci la richiesta POST
        data = request.json  # Ottieni i dati JSON dalla richiesta
        # Fai qualcosa con i dati ricevuti, ad esempio, restituisci una risposta
        user_id = data['userId']
        directory_list = dm.get_user_directory(user_id)
        response = jsonify({'directory_list': directory_list})
    else:
        # Se il metodo non e' OPTIONS o POST, restituisci un errore
        response = jsonify({'error': 'Metodo non supportato'})
        response.status_code = 405  # Metodo non consentito
    # Aggiungi gli header CORS alla risposta per consentire le richieste da origini diverse
    response.headers['Access-Control-Allow-Origin'] = '*'  # Cambia '*' con l'origine desiderata
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response
@app.route('/', methods=['OPTIONS', 'POST'])
def handle_request():
    if request.method == 'OPTIONS':
        # Gestisci la richiesta OPTIONS
        response = app.make_default_options_response()
        # Aggiungi i metodi consentiti nella risposta
        response.headers['Access-Control-Allow-Methods'] = 'POST'
        # Aggiungi gli header consentiti nella risposta
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    elif request.method == 'POST':
        # Gestisci la richiesta POST
        data = request.json  # Ottieni i dati JSON dalla richiesta
        # Fai qualcosa con i dati ricevuti, ad esempio, restituisci una risposta
        path_directory = "./data/" + data['userId'] + "/" + data['context']
        response_data = process_input(data['message'],path_directory)
        if data['function'] == 'message':
            response = jsonify({'message': response_data})
        elif data['function'] == 'mail':
            send_email(response_data,data['mail'],data['message'])
            response = jsonify({'message': 'mail sent'})
    else:
        # Se il metodo non e' OPTIONS o POST, restituisci un errore
        response = jsonify({'error': 'Metodo non supportato'})
        response.status_code = 405  # Metodo non consentito
    # Aggiungi gli header CORS alla risposta per consentire le richieste da origini diverse
    response.headers['Access-Control-Allow-Origin'] = '*'  # Cambia '*' con l'origine desiderata
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response
@app.route('/url', methods=['OPTIONS', 'POST'])
async def handle_url_request():
    if request.method == 'OPTIONS':
        # Gestisci la richiesta OPTIONS
        response = app.make_default_options_response()
        # Aggiungi i metodi consentiti nella risposta
        response.headers['Access-Control-Allow-Methods'] = 'POST'
        # Aggiungi gli header consentiti nella risposta
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    elif request.method == 'POST':
        # Gestisci la richiesta POST
        data = request.json  # Ottieni i dati JSON dalla richiesta
        # Fai qualcosa con i dati ricevuti, ad esempio, restituisci una risposta
        path_directory = "./data/" + data['userId'] + "/" + data['context']
        urls = str(data["message"])
        print(urls)
        await vector.urls_vectordb_maker(urls,path_directory)
        response = jsonify({'message': "Vectordb created successfully"})
    else:
        # Se il metodo non e' OPTIONS o POST, restituisci un errore
        response = jsonify({'error': 'Metodo non supportato'})
        response.status_code = 405  # Metodo non consentito
    # Aggiungi gli header CORS alla risposta per consentire le richieste da origini diverse
    response.headers['Access-Control-Allow-Origin'] = '*'  # Cambia '*' con l'origine desiderata
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response
if __name__ == '__main__':
    app.run(debug=True,port=8000)
\end{lstlisting}
\begin{lstlisting}[style=pythonstyle,caption={Codice del chatbot.py}, label={lst:chatbot}]
from langchain_community.vectorstores import Chroma
from langchain_community import embeddings
from langchain_community.llms import Ollama
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
import os
def process_input(question,persist_directory):
    if not os.path.exists(persist_directory):
        return "Invalid context, insert a valid context!!"
    db = Chroma(persist_directory=persist_directory, embedding_function=embeddings.OllamaEmbeddings(model='nomic-embed-text'))
    retriever = db.as_retriever()
    model_local = Ollama(model="mistral")
    #perform the RAG 
    question = "rispondi in italiano a: " + question
    after_rag_template = """Answer the question based only on the following context:
    {context}
    Question: {question}
    """
    after_rag_prompt = ChatPromptTemplate.from_template(after_rag_template)
    after_rag_chain = (
        {"context": retriever, "question": RunnablePassthrough()}
        | after_rag_prompt
        | model_local
        | StrOutputParser()
    )
    return after_rag_chain.invoke(question)
\end{lstlisting}
\begin{lstlisting}[style=pythonstyle,caption={Codice del mail\_chatbot.py}, label={lst:mailchatbot}]
import smtplib
from email.mime.text import MIMEText
def send_email(response,receiver_mail,question):
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login("alle.salva7@gmail.com","**************")
        text = "Question: " + question + "\n" + "Risposta: " + response
        msg = MIMEText(text, _charset='utf-8')
        msg['From'] = "alle.salva7@gmail.com"
        msg['To'] = receiver_mail
        msg['Subject'] = "CHATBOT response"
        server.sendmail(msg['From'],msg['To'],msg.as_string())
        server.quit()
\end{lstlisting}
\begin{lstlisting}[style=pythonstyle,caption={Codice del directory\_manager.py}, label={lst:directorymanager}]
import os
def get_user_directory(user_id):
    directory = "./data/" + user_id
    elements = os.listdir(directory)
    directory_list = [element for element in elements if os.path.isdir(os.path.join(directory,element))]
    return directory_list
def create_user_directory(user_id):
    path_directory = "./data/" + user_id
    os.mkdir(path_directory)
\end{lstlisting}
\begin{lstlisting}[style=pythonstyle,caption={Codice del url\_parser.py}, label={lst:urlparser}]
import requests
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
def get_same_domain_links(url):
    # Ottieni il contenuto HTML della pagina
    response = requests.get(url)
    # Controlla che la richiesta sia andata a buon fine
    if response.status_code == 200:
        # Analizza il contenuto HTML
        soup = BeautifulSoup(response.content, 'html.parser')
        # Ottieni il dominio base dell'URL passato
        base_domain = urlparse(url).netloc
        # Trova tutti i tag 'a' che contengono i link
        links = soup.find_all('a', href=True)
        # Lista per salvare i link con la stessa radice dell'URL passato
        same_domain_links = []
        for link in links:
            # Ottieni l'URL completo del link
            href = link['href']
            # Unisci l'URL relativo con l'URL di base per ottenere l'URL completo
            full_url = urljoin(url, href)
            # Controlla se l'URL appartiene allo stesso dominio dell'URL passato
            if urlparse(full_url).netloc == base_domain:
                same_domain_links.append(full_url)
        return same_domain_links
    else:
        # Se la richiesta non e' andata a buon fine, restituisci una lista vuota
        return []
\end{lstlisting}
\begin{lstlisting}[style=pythonstyle,caption={Codice del vector\_db\_maker.py}, label={lst:vector_db}]
    from PyPDF2 import PdfReader
import os
from bs4 import BeautifulSoup
from langchain_community.vectorstores import Chroma
from langchain_community import embeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain_community.document_loaders import WebBaseLoader
import requests
from urllib.parse import urlparse, urljoin
async def get_text(pdfs, directory_name):
    text = ""
    for pdf in pdfs:
        pdf_reader = PdfReader(pdf.filename)
        for page in pdf_reader.pages:
            text += page.extract_text()
        os.remove(pdf.filename)
    text_splitter = CharacterTextSplitter(
        separator="\n",
        chunk_size=3000,
        chunk_overlap=1000,
        length_function = len
    )
    chunks = text_splitter.split_text(text)
    Chroma.from_texts(
        texts=chunks,
        persist_directory=directory_name,
        embedding=embeddings.OllamaEmbeddings(model='nomic-embed-text'),
    )
def get_all_link(url):
    # Ottenere il contenuto HTML della pagina
    response = requests.get(url)
    # Verifica se la richiesta ha avuto successo
    if response.status_code == 200:
        # Parsing del contenuto HTML
        soup = BeautifulSoup(response.content, 'html.parser')
        base_domain = urlparse(url).netloc
        # Estrazione di tutti i tag 'a' (link)
        links = soup.find_all('a',href=True)
        # Lista per memorizzare gli URL dei link
        all_links = []
        for link in links:
            # Ottenere l'attributo 'href' degli elementi 'a'
            href = link.get('href')
            full_url = urljoin(url,href)
            # Verifica se l'URL e' valido
            if urlparse(full_url).netloc == base_domain:
                # Aggiungi l'URL all lista dei link
                all_links.append(full_url)
        return all_links
    else:
        # Se la richiesta non ha successo, stampa un messaggio di errore
        print("Errore durante la richiesta HTTP:", response.status_code)
        return []
def get_all_urls(urls_list):
    urls = []
    for url in urls_list:
        urls.append(url)
        links = get_all_link(url)
        urls.extend(links)
    return urls
def get_content_from_url(url):
    try:
        content = WebBaseLoader(url).load()
    except Exception:
        return None
    return content
async def urls_vectordb_maker(urls,directory_name):
    docs = []
    # Convert string of URLs to list
    urls_list = urls.split("\n")
    urls_list= get_all_urls(urls_list)
    for url in urls_list:
        content = get_content_from_url(url)
        if content:
            docs.append(content)
    #docs = [WebBaseLoader(url).load() for url in urls_list]
    docs_list = [item for sublist in docs for item in sublist]
    #split the text into chunks
    text_splitter = CharacterTextSplitter.from_tiktoken_encoder(chunk_size=7500, chunk_overlap=100)
    doc_splits = text_splitter.split_documents(docs_list)
    #convert text chunks into embeddings and store in vector database
    Chroma.from_documents(
        documents=doc_splits,
        persist_directory=directory_name,
        embedding=embeddings.OllamaEmbeddings(model='nomic-embed-text'),
    )
\end{lstlisting}
\include{capitoli/appendice2}
